{"ast":null,"code":"/** @license React v16.13.1\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var ReactDOM = require('react-dom');\n    var React = require('react');\n    var _assign = require('object-assign');\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n      ReactSharedInternals.ReactCurrentDispatcher = {\n        current: null\n      };\n    }\n    if (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n      ReactSharedInternals.ReactCurrentBatchConfig = {\n        suspense: null\n      };\n    }\n\n    function warn(format) {\n      {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        printWarning('warn', format, args);\n      }\n    }\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        printWarning('error', format, args);\n      }\n    }\n    function printWarning(level, format, args) {\n      {\n        var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n        if (!hasExistingStack) {\n          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame.getStackAddendum();\n          if (stack !== '') {\n            format += '%s';\n            args = args.concat([stack]);\n          }\n        }\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        });\n\n        argsWithFormat.unshift('Warning: ' + format);\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n        try {\n          var argIndex = 0;\n          var message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n          throw new Error(message);\n        } catch (x) {}\n      }\n    }\n    {\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n      }\n    }\n    var getFiberCurrentPropsFromNode = null;\n    var getInstanceFromNode = null;\n    var getNodeFromInstance = null;\n    function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n      getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n      getInstanceFromNode = getInstanceFromNodeImpl;\n      getNodeFromInstance = getNodeFromInstanceImpl;\n      {\n        if (!getNodeFromInstance || !getInstanceFromNode) {\n          error('EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n        }\n      }\n    }\n    var validateEventDispatches;\n    {\n      validateEventDispatches = function validateEventDispatches(event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        if (instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {\n          error('EventPluginUtils: Invalid `event`.');\n        }\n      };\n    }\n\n    function executeDispatchesInOrderStopAtTrueImpl(event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          }\n\n          if (dispatchListeners[i](event, dispatchInstances[i])) {\n            return dispatchInstances[i];\n          }\n        }\n      } else if (dispatchListeners) {\n        if (dispatchListeners(event, dispatchInstances)) {\n          return dispatchInstances;\n        }\n      }\n      return null;\n    }\n\n    function executeDispatchesInOrderStopAtTrue(event) {\n      var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n      event._dispatchInstances = null;\n      event._dispatchListeners = null;\n      return ret;\n    }\n\n    function executeDirectDispatch(event) {\n      {\n        validateEventDispatches(event);\n      }\n      var dispatchListener = event._dispatchListeners;\n      var dispatchInstance = event._dispatchInstances;\n      if (!!Array.isArray(dispatchListener)) {\n        {\n          throw Error(\"executeDirectDispatch(...): Invalid `event`.\");\n        }\n      }\n      event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n      var res = dispatchListener ? dispatchListener(event) : null;\n      event.currentTarget = null;\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n      return res;\n    }\n\n    function hasDispatches(event) {\n      return !!event._dispatchListeners;\n    }\n    var HostComponent = 5;\n    function getParent(inst) {\n      do {\n        inst = inst.return;\n      } while (inst && inst.tag !== HostComponent);\n      if (inst) {\n        return inst;\n      }\n      return null;\n    }\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n      var depthB = 0;\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      }\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      }\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      }\n\n      var depth = depthA;\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n      return null;\n    }\n\n    function isAncestor(instA, instB) {\n      while (instB) {\n        if (instA === instB || instA === instB.alternate) {\n          return true;\n        }\n        instB = getParent(instB);\n      }\n      return false;\n    }\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n      var i;\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], 'captured', arg);\n      }\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], 'bubbled', arg);\n      }\n    }\n    function isInteractive(tag) {\n      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n    }\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case 'onClick':\n        case 'onClickCapture':\n        case 'onDoubleClick':\n        case 'onDoubleClickCapture':\n        case 'onMouseDown':\n        case 'onMouseDownCapture':\n        case 'onMouseMove':\n        case 'onMouseMoveCapture':\n        case 'onMouseUp':\n        case 'onMouseUpCapture':\n        case 'onMouseEnter':\n          return !!(props.disabled && isInteractive(type));\n        default:\n          return false;\n      }\n    }\n\n    function getListener(inst, registrationName) {\n      var listener;\n\n      var stateNode = inst.stateNode;\n      if (!stateNode) {\n        return null;\n      }\n      var props = getFiberCurrentPropsFromNode(stateNode);\n      if (!props) {\n        return null;\n      }\n      listener = props[registrationName];\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n      if (!(!listener || typeof listener === 'function')) {\n        {\n          throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n        }\n      }\n      return listener;\n    }\n\n    function accumulateInto(current, next) {\n      if (!(next != null)) {\n        {\n          throw Error(\"accumulateInto(...): Accumulated items must not be null or undefined.\");\n        }\n      }\n      if (current == null) {\n        return next;\n      }\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n        current.push(next);\n        return current;\n      }\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n      return [current, next];\n    }\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        if (!inst) {\n          error('Dispatching inst must not be null');\n        }\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? getParentInstance(targetInst) : null;\n        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n        if (listener) {\n          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n        }\n      }\n    }\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n    }\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated(events, accumulateDirectDispatchesSingle);\n    }\n    var EVENT_POOL_SIZE = 10;\n\n    var EventInterface = {\n      type: null,\n      target: null,\n      currentTarget: function currentTarget() {\n        return null;\n      },\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function timeStamp(event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n    function functionThatReturnsTrue() {\n      return true;\n    }\n    function functionThatReturnsFalse() {\n      return false;\n    }\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n        delete this.isDefaultPrevented;\n        delete this.isPropagationStopped;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n        {\n          delete this[propName];\n        }\n\n        var normalize = Interface[propName];\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n      if (defaultPrevented) {\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = functionThatReturnsFalse;\n      }\n      this.isPropagationStopped = functionThatReturnsFalse;\n      return this;\n    }\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function preventDefault() {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n        if (!event) {\n          return;\n        }\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      },\n      stopPropagation: function stopPropagation() {\n        var event = this.nativeEvent;\n        if (!event) {\n          return;\n        }\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          event.cancelBubble = true;\n        }\n        this.isPropagationStopped = functionThatReturnsTrue;\n      },\n      persist: function persist() {\n        this.isPersistent = functionThatReturnsTrue;\n      },\n      isPersistent: functionThatReturnsFalse,\n      destructor: function destructor() {\n        var Interface = this.constructor.Interface;\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n        this.dispatchConfig = null;\n        this._targetInst = null;\n        this.nativeEvent = null;\n        this.isDefaultPrevented = functionThatReturnsFalse;\n        this.isPropagationStopped = functionThatReturnsFalse;\n        this._dispatchListeners = null;\n        this._dispatchInstances = null;\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n          Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n        }\n      }\n    });\n    SyntheticEvent.Interface = EventInterface;\n\n    SyntheticEvent.extend = function (Interface) {\n      var Super = this;\n      var E = function E() {};\n      E.prototype = Super.prototype;\n      var prototype = new E();\n      function Class() {\n        return Super.apply(this, arguments);\n      }\n      _assign(prototype, Class.prototype);\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.extend = Super.extend;\n      addEventPoolingTo(Class);\n      return Class;\n    };\n    addEventPoolingTo(SyntheticEvent);\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n      function warn(action, result) {\n        {\n          error(\"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n        }\n      }\n    }\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n      if (!(event instanceof EventConstructor)) {\n        {\n          throw Error(\"Trying to release an event instance into a pool of a different type.\");\n        }\n      }\n      event.destructor();\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n\n    var ResponderSyntheticEvent = SyntheticEvent.extend({\n      touchHistory: function touchHistory(nativeEvent) {\n        return null;\n      }\n    });\n\n    var TOP_TOUCH_START = 'touchstart';\n    var TOP_TOUCH_MOVE = 'touchmove';\n    var TOP_TOUCH_END = 'touchend';\n    var TOP_TOUCH_CANCEL = 'touchcancel';\n    var TOP_SCROLL = 'scroll';\n    var TOP_SELECTION_CHANGE = 'selectionchange';\n    var TOP_MOUSE_DOWN = 'mousedown';\n    var TOP_MOUSE_MOVE = 'mousemove';\n    var TOP_MOUSE_UP = 'mouseup';\n    function isStartish(topLevelType) {\n      return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n    }\n    function isMoveish(topLevelType) {\n      return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n    }\n    function isEndish(topLevelType) {\n      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n    }\n    var startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\n    var moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\n    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n\n    var MAX_TOUCH_BANK = 20;\n    var touchBank = [];\n    var touchHistory = {\n      touchBank: touchBank,\n      numberActiveTouches: 0,\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n    function timestampForTouch(touch) {\n      return touch.timeStamp || touch.timestamp;\n    }\n\n    function createTouchRecord(touch) {\n      return {\n        touchActive: true,\n        startPageX: touch.pageX,\n        startPageY: touch.pageY,\n        startTimeStamp: timestampForTouch(touch),\n        currentPageX: touch.pageX,\n        currentPageY: touch.pageY,\n        currentTimeStamp: timestampForTouch(touch),\n        previousPageX: touch.pageX,\n        previousPageY: touch.pageY,\n        previousTimeStamp: timestampForTouch(touch)\n      };\n    }\n    function resetTouchRecord(touchRecord, touch) {\n      touchRecord.touchActive = true;\n      touchRecord.startPageX = touch.pageX;\n      touchRecord.startPageY = touch.pageY;\n      touchRecord.startTimeStamp = timestampForTouch(touch);\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchRecord.previousPageX = touch.pageX;\n      touchRecord.previousPageY = touch.pageY;\n      touchRecord.previousTimeStamp = timestampForTouch(touch);\n    }\n    function getTouchIdentifier(_ref) {\n      var identifier = _ref.identifier;\n      if (!(identifier != null)) {\n        {\n          throw Error(\"Touch object is missing identifier.\");\n        }\n      }\n      {\n        if (identifier > MAX_TOUCH_BANK) {\n          error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n        }\n      }\n      return identifier;\n    }\n    function recordTouchStart(touch) {\n      var identifier = getTouchIdentifier(touch);\n      var touchRecord = touchBank[identifier];\n      if (touchRecord) {\n        resetTouchRecord(touchRecord, touch);\n      } else {\n        touchBank[identifier] = createTouchRecord(touch);\n      }\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    }\n    function recordTouchMove(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n      if (touchRecord) {\n        touchRecord.touchActive = true;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        {\n          warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n        }\n      }\n    }\n    function recordTouchEnd(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n      if (touchRecord) {\n        touchRecord.touchActive = false;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        {\n          warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n        }\n      }\n    }\n    function printTouch(touch) {\n      return JSON.stringify({\n        identifier: touch.identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        timestamp: timestampForTouch(touch)\n      });\n    }\n    function printTouchBank() {\n      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n      if (touchBank.length > MAX_TOUCH_BANK) {\n        printed += ' (original size: ' + touchBank.length + ')';\n      }\n      return printed;\n    }\n    var ResponderTouchHistoryStore = {\n      recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n        if (isMoveish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchMove);\n        } else if (isStartish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchStart);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n          if (touchHistory.numberActiveTouches === 1) {\n            touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n          }\n        } else if (isEndish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchEnd);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n          if (touchHistory.numberActiveTouches === 1) {\n            for (var i = 0; i < touchBank.length; i++) {\n              var touchTrackToCheck = touchBank[i];\n              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n                touchHistory.indexOfSingleActiveTouch = i;\n                break;\n              }\n            }\n            {\n              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n              if (activeRecord == null || !activeRecord.touchActive) {\n                error('Cannot find single active touch.');\n              }\n            }\n          }\n        }\n      },\n      touchHistory: touchHistory\n    };\n\n    function accumulate(current, next) {\n      if (!(next != null)) {\n        {\n          throw Error(\"accumulate(...): Accumulated items must not be null or undefined.\");\n        }\n      }\n      if (current == null) {\n        return next;\n      }\n\n      if (Array.isArray(current)) {\n        return current.concat(next);\n      }\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n      return [current, next];\n    }\n\n    var responderInst = null;\n\n    var trackedTouchCount = 0;\n    var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {\n      var oldResponderInst = responderInst;\n      responderInst = nextResponderInst;\n      if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n        ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n      }\n    };\n    var eventTypes = {\n      startShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onStartShouldSetResponder',\n          captured: 'onStartShouldSetResponderCapture'\n        },\n        dependencies: startDependencies\n      },\n      scrollShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onScrollShouldSetResponder',\n          captured: 'onScrollShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SCROLL]\n      },\n      selectionChangeShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onSelectionChangeShouldSetResponder',\n          captured: 'onSelectionChangeShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SELECTION_CHANGE]\n      },\n      moveShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onMoveShouldSetResponder',\n          captured: 'onMoveShouldSetResponderCapture'\n        },\n        dependencies: moveDependencies\n      },\n      responderStart: {\n        registrationName: 'onResponderStart',\n        dependencies: startDependencies\n      },\n      responderMove: {\n        registrationName: 'onResponderMove',\n        dependencies: moveDependencies\n      },\n      responderEnd: {\n        registrationName: 'onResponderEnd',\n        dependencies: endDependencies\n      },\n      responderRelease: {\n        registrationName: 'onResponderRelease',\n        dependencies: endDependencies\n      },\n      responderTerminationRequest: {\n        registrationName: 'onResponderTerminationRequest',\n        dependencies: []\n      },\n      responderGrant: {\n        registrationName: 'onResponderGrant',\n        dependencies: []\n      },\n      responderReject: {\n        registrationName: 'onResponderReject',\n        dependencies: []\n      },\n      responderTerminate: {\n        registrationName: 'onResponderTerminate',\n        dependencies: []\n      }\n    };\n\n    function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;\n\n      var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);\n\n      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n      var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      if (skipOverBubbleShouldSetFrom) {\n        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n      } else {\n        accumulateTwoPhaseDispatches(shouldSetEvent);\n      }\n      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n      if (!shouldSetEvent.isPersistent()) {\n        shouldSetEvent.constructor.release(shouldSetEvent);\n      }\n      if (!wantsResponderInst || wantsResponderInst === responderInst) {\n        return null;\n      }\n      var extracted;\n      var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(grantEvent);\n      var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n      if (responderInst) {\n        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n        terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminationRequestEvent);\n        var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n        if (!terminationRequestEvent.isPersistent()) {\n          terminationRequestEvent.constructor.release(terminationRequestEvent);\n        }\n        if (shouldSwitch) {\n          var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(terminateEvent);\n          extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n          changeResponder(wantsResponderInst, blockHostResponder);\n        } else {\n          var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(rejectEvent);\n          extracted = accumulate(extracted, rejectEvent);\n        }\n      } else {\n        extracted = accumulate(extracted, grantEvent);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      }\n      return extracted;\n    }\n\n    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n      return topLevelInst && (\n      topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n    }\n\n    function noResponderTouches(nativeEvent) {\n      var touches = nativeEvent.touches;\n      if (!touches || touches.length === 0) {\n        return true;\n      }\n      for (var i = 0; i < touches.length; i++) {\n        var activeTouch = touches[i];\n        var target = activeTouch.target;\n        if (target !== null && target !== undefined && target !== 0) {\n          var targetInst = getInstanceFromNode(target);\n          if (isAncestor(responderInst, targetInst)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    var ResponderEventPlugin = {\n      _getResponder: function _getResponder() {\n        return responderInst;\n      },\n      eventTypes: eventTypes,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n        if (isStartish(topLevelType)) {\n          trackedTouchCount += 1;\n        } else if (isEndish(topLevelType)) {\n          if (trackedTouchCount >= 0) {\n            trackedTouchCount -= 1;\n          } else {\n            {\n              warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n            }\n            return null;\n          }\n        }\n        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;\n\n        var isResponderTouchStart = responderInst && isStartish(topLevelType);\n        var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n        var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n        var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n        if (incrementalTouch) {\n          var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(gesture);\n          extracted = accumulate(extracted, gesture);\n        }\n        var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n        var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n        var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n        if (finalTouch) {\n          var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(finalEvent);\n          extracted = accumulate(extracted, finalEvent);\n          changeResponder(null);\n        }\n        return extracted;\n      },\n      GlobalResponderHandler: null,\n      injection: {\n        injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {\n          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n        }\n      }\n    };\n\n    var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events,\n      getInstanceFromNode$1 = _ReactDOM$__SECRET_IN[0],\n      getNodeFromInstance$1 = _ReactDOM$__SECRET_IN[1],\n      getFiberCurrentPropsFromNode$1 = _ReactDOM$__SECRET_IN[2],\n      injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n    setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\n    var ReactDOMUnstableNativeDependencies = Object.freeze({\n      __proto__: null,\n      ResponderEventPlugin: ResponderEventPlugin,\n      ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n      injectEventPluginsByName: injectEventPluginsByName\n    });\n    var unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n    module.exports = unstableNativeDependencies;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","ReactDOM","require","React","_assign","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","hasOwnProperty","ReactCurrentDispatcher","current","ReactCurrentBatchConfig","suspense","warn","format","_len","arguments","length","args","Array","_key","printWarning","error","_len2","_key2","level","hasExistingStack","indexOf","ReactDebugCurrentFrame","stack","getStackAddendum","concat","argsWithFormat","map","item","unshift","Function","prototype","apply","call","console","argIndex","message","replace","Error","x","window","dispatchEvent","document","createEvent","fakeNode","createElement","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","validateEventDispatches","event","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatchesInOrderStopAtTrueImpl","i","isPropagationStopped","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","currentTarget","res","hasDispatches","HostComponent","getParent","inst","return","tag","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","push","isInteractive","shouldPreventMouseEvent","name","type","props","disabled","getListener","registrationName","listener","stateNode","accumulateInto","next","forEachAccumulated","arr","cb","scope","forEach","listenerAtPhase","propagationPhase","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","EVENT_POOL_SIZE","EventInterface","target","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","nativeEvent","nativeEventTarget","preventDefault","stopPropagation","isDefaultPrevented","Interface","constructor","propName","normalize","returnValue","cancelBubble","persist","isPersistent","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","getVal","isFunction","configurable","set","get","val","action","result","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","release","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","TOP_MOUSE_DOWN","TOP_MOUSE_MOVE","TOP_MOUSE_UP","isStartish","topLevelType","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes","startShouldSetResponder","bubbled","captured","dependencies","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","undefined","_getResponder","extractEvents","eventSystemFlags","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injection","injectGlobalResponderHandler","_ReactDOM$__SECRET_IN","Events","getInstanceFromNode$1","getNodeFromInstance$1","getFiberCurrentPropsFromNode$1","injectEventPluginsByName","ReactDOMUnstableNativeDependencies","freeze","__proto__","unstableNativeDependencies","module","exports"],"sources":["C:/Users/prariya/Desktop/Modhiw/client/node_modules/react-native-phone-number-input/node_modules/react-dom/cjs/react-dom-unstable-native-dependencies.development.js"],"sourcesContent":["/** @license React v16.13.1\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar ReactDOM = require('react-dom');\nvar React = require('react');\nvar _assign = require('object-assign');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.\n// Current owner and dispatcher used to share the same ref,\n// but PR #14548 split them out to better support the react-debug-tools package.\n\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n  ReactSharedInternals.ReactCurrentDispatcher = {\n    current: null\n  };\n}\n\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n  ReactSharedInternals.ReactCurrentBatchConfig = {\n    suspense: null\n  };\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    printWarning('warn', format, args);\n  }\n}\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n\n    if (!hasExistingStack) {\n      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n      var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n      if (stack !== '') {\n        format += '%s';\n        args = args.concat([stack]);\n      }\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(message);\n    } catch (x) {}\n  }\n}\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n  }\n}\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\nfunction setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n\n  {\n    if (!getNodeFromInstance || !getInstanceFromNode) {\n      error('EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n    }\n  }\n}\nvar validateEventDispatches;\n\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    if (instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {\n      error('EventPluginUtils: Invalid `event`.');\n    }\n  };\n}\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\n\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n\n  {\n    validateEventDispatches(event);\n  }\n\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n\n  return null;\n}\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n\n  if (!!Array.isArray(dispatchListener)) {\n    {\n      throw Error( \"executeDirectDispatch(...): Invalid `event`.\" );\n    }\n  }\n\n  event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\nvar HostComponent = 5;\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n\n  if (inst) {\n    return inst;\n  }\n\n  return null;\n}\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\n\n\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n\n  var depthB = 0;\n\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  } // If A is deeper, crawl up.\n\n\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  } // If B is deeper, crawl up.\n\n\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  } // Walk in lockstep until we find a match.\n\n\n  var depth = depthA;\n\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n\n  return null;\n}\n/**\n * Return if A is an ancestor of B.\n */\n\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n\n    instB = getParent(instB);\n  }\n\n  return false;\n}\n/**\n * Return the parent instance of the passed-in instance.\n */\n\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\n\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n\n  var i;\n\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n    case 'onMouseEnter':\n      return !!(props.disabled && isInteractive(type));\n\n    default:\n      return false;\n  }\n}\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\n\n\nfunction getListener(inst, registrationName) {\n  var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n\n  var stateNode = inst.stateNode;\n\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n\n  var props = getFiberCurrentPropsFromNode(stateNode);\n\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n\n  listener = props[registrationName];\n\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n\n  if (!(!listener || typeof listener === 'function')) {\n    {\n      throw Error( \"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\" );\n    }\n  }\n\n  return listener;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  if (!(next != null)) {\n    {\n      throw Error( \"accumulateInto(...): Accumulated items must not be null or undefined.\" );\n    }\n  }\n\n  if (current == null) {\n    return next;\n  } // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n\n\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\n\n\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    if (!inst) {\n      error('Dispatching inst must not be null');\n    }\n  }\n\n  var listener = listenerAtPhase(inst, event, phase);\n\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\n\n\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\n\n\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EVENT_POOL_SIZE = 10;\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\n\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function () {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\n\n\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n  var Interface = this.constructor.Interface;\n\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n\n    var normalize = Interface[propName];\n\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\n\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n\n  _assign(prototype, Class.prototype);\n\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\n\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    {\n      error(\"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n    }\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n\n  if (!(event instanceof EventConstructor)) {\n    {\n      throw Error( \"Trying to release an event instance into a pool of a different type.\" );\n    }\n  }\n\n  event.destructor();\n\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\n\nvar ResponderSyntheticEvent = SyntheticEvent.extend({\n  touchHistory: function (nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\n// Note: ideally these would be imported from DOMTopLevelEventTypes,\n// but our build system currently doesn't let us do that from a fork.\nvar TOP_TOUCH_START = 'touchstart';\nvar TOP_TOUCH_MOVE = 'touchmove';\nvar TOP_TOUCH_END = 'touchend';\nvar TOP_TOUCH_CANCEL = 'touchcancel';\nvar TOP_SCROLL = 'scroll';\nvar TOP_SELECTION_CHANGE = 'selectionchange';\nvar TOP_MOUSE_DOWN = 'mousedown';\nvar TOP_MOUSE_MOVE = 'mousemove';\nvar TOP_MOUSE_UP = 'mouseup';\nfunction isStartish(topLevelType) {\n  return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n}\nfunction isMoveish(topLevelType) {\n  return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n}\nfunction isEndish(topLevelType) {\n  return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n}\nvar startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\nvar moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\nvar endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (!(identifier != null)) {\n    {\n      throw Error( \"Touch object is missing identifier.\" );\n    }\n  }\n\n  {\n    if (identifier > MAX_TOUCH_BANK) {\n      error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    {\n      warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n    }\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    {\n      warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n    }\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function (topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (activeRecord == null || !activeRecord.touchActive) {\n            error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulate(current, next) {\n  if (!(next != null)) {\n    {\n      throw Error( \"accumulate(...): Accumulated items must not be null or undefined.\" );\n    }\n  }\n\n  if (current == null) {\n    return next;\n  } // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n\n\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\n\nvar responderInst = null;\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\n\nvar trackedTouchCount = 0;\n\nvar changeResponder = function (nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onStartShouldSetResponder',\n      captured: 'onStartShouldSetResponderCapture'\n    },\n    dependencies: startDependencies\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onScrollShouldSetResponder',\n      captured: 'onScrollShouldSetResponderCapture'\n    },\n    dependencies: [TOP_SCROLL]\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelectionChangeShouldSetResponder',\n      captured: 'onSelectionChangeShouldSetResponderCapture'\n    },\n    dependencies: [TOP_SELECTION_CHANGE]\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onMoveShouldSetResponder',\n      captured: 'onMoveShouldSetResponderCapture'\n    },\n    dependencies: moveDependencies\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {\n    registrationName: 'onResponderStart',\n    dependencies: startDependencies\n  },\n  responderMove: {\n    registrationName: 'onResponderMove',\n    dependencies: moveDependencies\n  },\n  responderEnd: {\n    registrationName: 'onResponderEnd',\n    dependencies: endDependencies\n  },\n  responderRelease: {\n    registrationName: 'onResponderRelease',\n    dependencies: endDependencies\n  },\n  responderTerminationRequest: {\n    registrationName: 'onResponderTerminationRequest',\n    dependencies: []\n  },\n  responderGrant: {\n    registrationName: 'onResponderGrant',\n    dependencies: []\n  },\n  responderReject: {\n    registrationName: 'onResponderReject',\n    dependencies: []\n  },\n  responderTerminate: {\n    registrationName: 'onResponderTerminate',\n    dependencies: []\n  }\n};\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginRegistry`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginRegistry` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)\n * - `touchStart`              (`EventPluginRegistry` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.\n\n  var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n\n  var extracted;\n  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n\n  return extracted;\n}\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\n\n\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return topLevelInst && ( // responderIgnoreScroll: We are trying to migrate away from specifically\n  // tracking native scroll events here and responderIgnoreScroll indicates we\n  // will send topTouchCancel to handle canceling touch events instead\n  topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n}\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\n\n\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function () {\n    return responderInst;\n  },\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        {\n          warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n        }\n\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null; // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n    var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    return extracted;\n  },\n  GlobalResponderHandler: null,\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function (GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    }\n  }\n};\n\n// Keep in sync with ReactDOM.js, ReactTestUtils.js, and ReactTestUtilsAct.js:\n\nvar _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events,\n    getInstanceFromNode$1 = _ReactDOM$__SECRET_IN[0],\n    getNodeFromInstance$1 = _ReactDOM$__SECRET_IN[1],\n    getFiberCurrentPropsFromNode$1 = _ReactDOM$__SECRET_IN[2],\n    injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\nsetComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\n\nvar ReactDOMUnstableNativeDependencies = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ResponderEventPlugin: ResponderEventPlugin,\n  ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n  injectEventPluginsByName: injectEventPluginsByName\n});\n\nvar unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n\nmodule.exports = unstableNativeDependencies;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}