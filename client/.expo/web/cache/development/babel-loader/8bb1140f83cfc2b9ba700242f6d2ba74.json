{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _AccessibilityUtil = _interopRequireDefault(require(\"../../modules/AccessibilityUtil\"));\nvar _BoundingDimensions = _interopRequireDefault(require(\"./BoundingDimensions\"));\nvar _findNodeHandle = _interopRequireDefault(require(\"../findNodeHandle\"));\nvar _normalizeCssColor = _interopRequireDefault(require(\"normalize-css-color\"));\nvar _Position = _interopRequireDefault(require(\"./Position\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _TouchEventUtils = _interopRequireDefault(require(\"fbjs/lib/TouchEventUtils\"));\nvar _UIManager = _interopRequireDefault(require(\"../UIManager\"));\nvar _View = _interopRequireDefault(require(\"../View\"));\n\nvar States = {\n  NOT_RESPONDER: 'NOT_RESPONDER',\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n  ERROR: 'ERROR'\n};\n\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\n\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\n\nvar Signals = {\n  DELAY: 'DELAY',\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\n};\n\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n};\n\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\n\nvar TouchableMixin = {\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n    this._touchableNode = (0, _findNodeHandle.default)(this);\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = function (e) {\n        if (_this._isTouchableKeyboardActive) {\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            _this.touchableHandleResponderTerminate({\n              nativeEvent: e\n            });\n          }\n          _this._isTouchableKeyboardActive = false;\n        }\n      };\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\n    }\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget;\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this.state.touchable.positionOnActivate = null;\n      this._handleDelay(e);\n    }\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n      return;\n    }\n\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left;\n      pressExpandTop += hitSlop.top;\n      pressExpandRight += hitSlop.right;\n      pressExpandBottom += hitSlop.bottom;\n    }\n    var touch = _TouchEventUtils.default.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n    if (isTouchWithinActive) {\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n      var curState = this.state.touchable.touchState;\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n    if (tag == null) {\n      return;\n    }\n    _UIManager.default.measure(tag, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(x, y, width, height, globalX, globalY) {\n    if (!x && !y && !width && !height && !globalX && !globalY) {\n      return;\n    }\n    this.state.touchable.positionOnActivate && _Position.default.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate &&\n    _BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = _Position.default.getPooled(globalX, globalY);\n    this.state.touchable.dimensionsOnActivate = _BoundingDimensions.default.getPooled(width, height);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = _TouchEventUtils.default.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n      get locationX() {\n        return touch && touch.locationX;\n      },\n      get locationY() {\n        return touch && touch.locationY;\n      }\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n    var newIsHighlight = this._isHighlight(nextState);\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n    if (!IsActive[curState] && IsActive[nextState]) {\n      this._remeasureMetricsOnActivation();\n    }\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (\n      !hasLongPressHandler ||\n      !this.touchableLongPressCancelsPress());\n\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          this._startHighlight(e);\n          this._endHighlight(e);\n        }\n        this.touchableHandlePress(e);\n      }\n    }\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n  _endHighlight: function _endHighlight(e) {\n    var _this2 = this;\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this2.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var ENTER = 13;\n    var SPACE = 32;\n    var type = e.type,\n      which = e.which;\n    if (which === ENTER || which === SPACE) {\n      if (type === 'keydown') {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === 'keyup') {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n      e.stopPropagation();\n      if (!(which === ENTER && _AccessibilityUtil.default.propsToAriaRole(this.props) === 'link')) {\n        e.preventDefault();\n      }\n    }\n  }\n};\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false,\n  renderDebugView: function renderDebugView(_ref) {\n    var color = _ref.color,\n      hitSlop = _ref.hitSlop;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Touchable.TOUCH_TARGET_DEBUG) {\n        return null;\n      }\n      var debugHitSlopStyle = {};\n      hitSlop = hitSlop || {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n      };\n      for (var key in hitSlop) {\n        debugHitSlopStyle[key] = -hitSlop[key];\n      }\n      var hexColor = '#' + ('00000000' + (0, _normalizeCssColor.default)(color).toString(16)).substr(-8);\n      return _react.default.createElement(_View.default, {\n        pointerEvents: 'none',\n        style: Object.assign({\n          position: 'absolute',\n          borderColor: hexColor.slice(0, -2) + '55',\n          borderWidth: 1,\n          borderStyle: 'dashed',\n          backgroundColor: hexColor.slice(0, -2) + '0F'\n        }, debugHitSlopStyle)\n      });\n    }\n  }\n};\nvar _default = Touchable;\nexports.default = _default;","map":{"version":3,"names":["States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","IsActive","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","TouchableMixin","componentDidMount","_this","_touchableNode","findNodeHandle","addEventListener","_touchableBlurListener","e","_isTouchableKeyboardActive","state","touchable","touchState","touchableHandleResponderTerminate","nativeEvent","componentWillUnmount","removeEventListener","touchableDelayTimeout","clearTimeout","longPressDelayTimeout","pressOutDelayTimeout","touchableGetInitialState","undefined","responderID","touchableHandleResponderTerminationRequest","props","rejectResponderTermination","touchableHandleStartShouldSetResponder","disabled","touchableLongPressCancelsPress","touchableHandleResponderGrant","dispatchID","currentTarget","persist","_receiveSignal","delayMS","touchableGetHighlightDelayMS","Math","max","isNaN","setTimeout","_handleDelay","bind","positionOnActivate","longDelayMS","touchableGetLongPressDelayMS","_handleLongDelay","touchableHandleResponderRelease","touchableHandleResponderMove","dimensionsOnActivate","pressRectOffset","touchableGetPressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touchableGetHitSlop","touch","TouchEventUtils","extractSingleTouch","pageX","pageY","pressInLocation","movedDistance","_getDistanceBetweenPoints","_cancelLongPressDelayTimeout","isTouchWithinActive","width","height","curState","_remeasureMetricsOnActivation","tag","UIManager","measure","_handleQueryLayout","x","y","globalX","globalY","Position","release","BoundingDimensions","getPooled","console","signal","nextState","Error","_performSideEffectsForTransition","_isHighlight","_savePressInLocation","locationX","locationY","aX","aY","bX","bY","deltaX","deltaY","sqrt","curIsHighlight","newIsHighlight","isFinalSignal","touchableHandleLongPress","_startHighlight","_endHighlight","hasLongPressHandler","onLongPress","pressIsLongButStillCallOnPress","shouldInvokePress","touchableHandlePress","touchableHandleActivePressIn","_this2","touchableHandleActivePressOut","touchableGetPressOutDelayMS","touchableHandleKeyEvent","ENTER","SPACE","type","which","stopPropagation","AccessibilityUtil","propsToAriaRole","preventDefault","Touchable","Mixin","TOUCH_TARGET_DEBUG","renderDebugView","_ref","color","process","env","NODE_ENV","debugHitSlopStyle","key","hexColor","normalizeColor","toString","substr","React","createElement","View","pointerEvents","style","Object","assign","position","borderColor","slice","borderWidth","borderStyle","backgroundColor"],"sources":["C:/Users/prariya/Desktop/Modhiw/client/node_modules/react-native-phone-number-input/node_modules/react-native-web/dist/exports/Touchable/index.js"],"sourcesContent":["/* eslint-disable react/prop-types */\n\n/**\n * Copyright (c) 2016-present, Nicolas Gallagher.\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport AccessibilityUtil from '../../modules/AccessibilityUtil';\nimport BoundingDimensions from './BoundingDimensions';\nimport findNodeHandle from '../findNodeHandle';\nimport normalizeColor from 'normalize-css-color';\nimport Position from './Position';\nimport React from 'react';\nimport TouchEventUtils from 'fbjs/lib/TouchEventUtils';\nimport UIManager from '../UIManager';\nimport View from '../View';\n\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\nvar States = {\n  NOT_RESPONDER: 'NOT_RESPONDER', // Not the responder\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN', // Responder, inactive, in the `PressRect`\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT', // Responder, inactive, out of `PressRect`\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN', // Responder, active, in the `PressRect`\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT', // Responder, active, out of `PressRect`\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN', // Responder, active, in the `PressRect`, after long press threshold\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT', // Responder, active, out of `PressRect`, after long press threshold\n  ERROR: 'ERROR'\n};\n\n/**\n * Quick lookup map for states that are considered to be \"active\"\n */\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\n\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\n\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\n\n/**\n * Inputs to the state machine.\n */\nvar Signals = {\n  DELAY: 'DELAY',\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\n};\n\n/**\n * Mapping from States x Signals => States\n */\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n};\n\n// ==== Typical Constants for integrating into UI components ====\n// var HIT_EXPAND_PX = 20;\n// var HIT_VERT_OFFSET_PX = 10;\nvar HIGHLIGHT_DELAY_MS = 130;\n\nvar PRESS_EXPAND_PX = 20;\n\nvar LONG_PRESS_THRESHOLD = 500;\n\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\n\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\n\n// Default amount \"active\" region protrudes beyond box\n\n/**\n * By convention, methods prefixed with underscores are meant to be @private,\n * and not @protected. Mixers shouldn't access them - not even to provide them\n * as callback handlers.\n *\n *\n * ========== Geometry =========\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n *  +--------------------------+\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\n *  |  +--------------------+  |   to become the responder.\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\n *  |  |  |              |  |  |   and before letting up, the Visual React\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\n *  |  |     HitRect        |  |   for being highlighted (so long as the\n *  |  +--------------------+  |   press remains in the `PressRect`).\n *  |        PressRect     o   |\n *  +----------------------|---+\n *           Out Region    |\n *                         +-----+ This gap between the `HitRect` and\n *                                 `PressRect` allows a touch to move far away\n *                                 from the original hit rect, and remain\n *                                 highlighted, and eligible for a \"Press\".\n *                                 Customize this via\n *                                 `touchableGetPressRectOffset()`.\n *\n *\n *\n * ======= State Machine =======\n *\n * +-------------+ <---+ RESPONDER_RELEASE\n * |NOT_RESPONDER|\n * +-------------+ <---+ RESPONDER_TERMINATED\n *     +\n *     | RESPONDER_GRANT (HitRect)\n *     v\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\n * +---------------------------+          +-------------------------+                +------------------------------+\n *     +            ^                         +           ^                                 +           ^\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\n *     |            |                         |           |                                 |           |\n *     v            +                         v           +                                 v           +\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\n * +----------------------------+         +--------------------------+               +-------------------------------+\n *\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the `touchableHandlePress` abstract method invocation that occurs\n * when a responder is released while in either of the \"Press\" states.\n *\n * The other important side effects are the highlight abstract method\n * invocations (internal callbacks) to be implemented by the mixer.\n *\n *\n * @lends Touchable.prototype\n */\nvar TouchableMixin = {\n  // HACK (part 1): basic support for touchable interactions using a keyboard\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n\n    this._touchableNode = findNodeHandle(this);\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = function (e) {\n        if (_this._isTouchableKeyboardActive) {\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            _this.touchableHandleResponderTerminate({ nativeEvent: e });\n          }\n          _this._isTouchableKeyboardActive = false;\n        }\n      };\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\n    }\n  },\n\n  /**\n   * Clear all timeouts on unmount\n   */\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\n    }\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n\n  /**\n   * It's prefer that mixins determine state in this way, having the class\n   * explicitly mix the state in the one and only `getInitialState` method.\n   *\n   * @return {object} State object to be placed inside of\n   * `this.state.touchable`.\n   */\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: { touchState: undefined, responderID: null }\n    };\n  },\n\n  // ==== Hooks to Gesture Responder system ====\n  /**\n   * Must return true if embedded in a native platform scroll view.\n   */\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n\n  /**\n   * Must return true to start the process of `Touchable`.\n   */\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n\n  /**\n   * Return true to cancel press on long press.\n   */\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderGrant` event.\n   */\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget;\n    // Since e is used in a callback invoked on another event loop\n    // (as in setTimeout etc), we need to call e.persist() on the\n    // event to make sure it doesn't get reused in the event object pool.\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this.state.touchable.positionOnActivate = null;\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderRelease` event.\n   */\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderTerminate` event.\n   */\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderMove` event.\n   */\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    // Not enough time elapsed yet, wait for highlight -\n    // this is just a perf optimization.\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n      return;\n    }\n\n    // Measurement may not have returned yet.\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left;\n      pressExpandTop += hitSlop.top;\n      pressExpandRight += hitSlop.right;\n      pressExpandBottom += hitSlop.bottom;\n    }\n\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n    if (isTouchWithinActive) {\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n      var curState = this.state.touchable.touchState;\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        // fix for t7967420\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  // ==== Abstract Application Callbacks ====\n\n  /**\n   * Invoked when the item should be highlighted. Mixers should implement this\n   * to visually distinguish the `VisualRect` so that the user knows that\n   * releasing a touch will result in a \"selection\" (analog to click).\n   *\n   * @abstract\n   * touchableHandleActivePressIn: function,\n   */\n\n  /**\n   * Invoked when the item is \"active\" (in that it is still eligible to become\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n   * again and the mixer should probably highlight the `VisualRect` again. This\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\n   * the user is depressing the mouse/touch.\n   *\n   * @abstract\n   * touchableHandleActivePressOut: function\n   */\n\n  /**\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\n   * letting up while the item was either in the state\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n   *\n   * @abstract\n   * touchableHandlePress: function\n   */\n\n  /**\n   * Invoked when the item is long pressed - meaning the interaction ended by\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\n   * default any `touchableHandlePress` callback will not be invoked. To\n   * override this default behavior, override `touchableLongPressCancelsPress`\n   * to return false. As a result, `touchableHandlePress` will be called when\n   * lifting up, even if `touchableHandleLongPress` has also been called.\n   *\n   * @abstract\n   * touchableHandleLongPress: function\n   */\n\n  /**\n   * Returns the number of millis to wait before triggering a highlight.\n   *\n   * @abstract\n   * touchableGetHighlightDelayMS: function\n   */\n\n  /**\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n   * numbers mean the size expands outwards.\n   *\n   * @abstract\n   * touchableGetPressRectOffset: function\n   */\n\n  // ==== Internal Logic ====\n\n  /**\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n   * should result in points that are in the same coordinate system as an\n   * event's `globalX/globalY` data values.\n   *\n   * - Consider caching this for the lifetime of the component, or possibly\n   *   being able to share this cache between any `ScrollMap` view.\n   *\n   * @sideeffects\n   * @private\n   */\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n    if (tag == null) {\n      return;\n    }\n\n    UIManager.measure(tag, this._handleQueryLayout);\n  },\n\n  _handleQueryLayout: function _handleQueryLayout(x, y, width, height, globalX, globalY) {\n    // don't do anything if UIManager failed to measure node\n    if (!x && !y && !width && !height && !globalX && !globalY) {\n      return;\n    }\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate &&\n    // $FlowFixMe\n    BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n    // $FlowFixMe\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(width, height);\n  },\n\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n    this._receiveSignal(Signals.DELAY, e);\n  },\n\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   *\n   * @param {Signals} signal State machine signal.\n   * @throws Error if invalid state transition or unrecognized signal.\n   * @sideeffects\n   */\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n      this.state.touchable.touchState = nextState;\n    }\n  },\n\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n      get locationX() {\n        return touch && touch.locationX;\n      },\n      get locationY() {\n        return touch && touch.locationY;\n      }\n    };\n  },\n\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n\n  /**\n   * Will perform a transition between touchable states, and identify any\n   * highlighting or unhighlighting that must be performed for this particular\n   * transition.\n   *\n   * @param {States} curState Current Touchable state.\n   * @param {States} nextState Next Touchable state.\n   * @param {Signal} signal Signal that triggered the transition.\n   * @param {Event} e Native event.\n   * @sideeffects\n   */\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (!IsActive[curState] && IsActive[nextState]) {\n      this._remeasureMetricsOnActivation();\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing..\n      !hasLongPressHandler || // But either has no long handler\n      !this.touchableLongPressCancelsPress()); // or we're told to ignore it.\n\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          // we never highlighted because of delay, but we should highlight now\n          this._startHighlight(e);\n          this._endHighlight(e);\n        }\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n\n  _endHighlight: function _endHighlight(e) {\n    var _this2 = this;\n\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this2.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n\n  // HACK (part 2): basic support for touchable interactions using a keyboard (including\n  // delays and longPress)\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var ENTER = 13;\n    var SPACE = 32;\n    var type = e.type,\n        which = e.which;\n\n    if (which === ENTER || which === SPACE) {\n      if (type === 'keydown') {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === 'keyup') {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n      e.stopPropagation();\n      // prevent the default behaviour unless the Touchable functions as a link\n      // and Enter is pressed\n      if (!(which === ENTER && AccessibilityUtil.propsToAriaRole(this.props) === 'link')) {\n        e.preventDefault();\n      }\n    }\n  }\n};\n\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false, // Highlights all touchable targets. Toggle with Inspector.\n  /**\n   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).\n   */\n  renderDebugView: function renderDebugView(_ref) {\n    var color = _ref.color,\n        hitSlop = _ref.hitSlop;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Touchable.TOUCH_TARGET_DEBUG) {\n        return null;\n      }\n      var debugHitSlopStyle = {};\n      hitSlop = hitSlop || { top: 0, bottom: 0, left: 0, right: 0 };\n      for (var key in hitSlop) {\n        debugHitSlopStyle[key] = -hitSlop[key];\n      }\n      var hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);\n      return React.createElement(View, {\n        pointerEvents: 'none',\n        style: Object.assign({\n          position: 'absolute',\n          borderColor: hexColor.slice(0, -2) + '55', // More opaque\n          borderWidth: 1,\n          borderStyle: 'dashed',\n          backgroundColor: hexColor.slice(0, -2) + '0F' }, debugHitSlopStyle)\n      });\n    }\n  }\n};\n\nexport default Touchable;"],"mappings":"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"},"metadata":{},"sourceType":"script"}